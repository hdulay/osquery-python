#!/usr/bin/env python

import osquery
import json
import sys
import os
from confluent_kafka import Producer


def config():
    path = os.getenv('CCLOUD_CONFIG') if "CCLOUD_CONFIG" in os.environ else "ccloud.json"
    with open(path) as json_file:
        config = json.load(json_file)
    return config



@osquery.register_plugin
class CCloudConfigPlugin(osquery.ConfigPlugin):
    """Example config plugin"""

    def __init__(self):
        self.config = config()
        print("config {}".format(self.config['source']))

    def name(self):
        return "ccloud_config"

    def content(self):
        return [
            {
                "source_one": json.dumps(self.config['source']),
            }
        ]

@osquery.register_plugin
class CCloudLoggerPlugin(osquery.LoggerPlugin):
    """Example logger plugin"""

    def __init__(self):
        self.config = config()
        self.p = Producer(self.config['ccloud'])    

    def name(self):
        return "ccloud_logger"

    def delivery_report(self, err = None, msg = None):
        """ Called once for each message produced to indicate delivery result.
            Triggered by poll() or flush(). """
        if err is not None:
            print('Message delivery failed: {}'.format(err))
        else:
            print('Message delivered to {} [{}]'.format(msg.topic(), msg.partition()))

    def log_string(self, value):
        # Trigger any available delivery report callbacks from previous produce() calls
        self.p.poll(0)

        # Evaluating the key expression in the configuration file to pull the key out of
        # the JSON document. If 'key' isn't provided, key is set to None.
        key = eval("json.loads(value){}".format(self.config['key'])) if "key" in self.config else None

        # Asynchronously produce a message, the delivery report callback
        # will be triggered from poll() above, or flush() below, when the message has
        # been successfully delivered or failed permanently.
        self.p.produce(topic=self.config['topic'], value=value.encode('utf-8'), callback=self.delivery_report, key=key)

        # Wait for any outstanding messages to be delivered and delivery report
        # callbacks to be triggered.
        self.p.flush()

        return osquery.extensions.ttypes.ExtensionStatus(code=0, message="OK")




if __name__ == "__main__":
    osquery.start_extension(
        name="confluent_cloud",
        version="1.0.0",)
